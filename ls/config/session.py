import pickle
import hashlib
import os
import re
from abc import ABC, abstractmethod
from datetime import datetime, timedelta
from shutil import rmtree
from time import time
from random import random
import jwt

from .common import PIPES_CONFIG_DIRECTORY, PIPES_SESSION_EXPIRE
from .settings import ClientSettings


class AbstractSessionManager(ABC):
    """Abstract session manager class"""

    def validate_session_id(self, session_id):
        """Validate if given session_id is a hex string generated by hashlib hexdiget method"""
        length = hashlib.sha256().digest_size * 2
        pattern = re.compile("^[a-f0-9]{%d}$" % length)
        try:
            return pattern.match(session_id) is not None
        except TypeError:
            return False

    @abstractmethod
    def save_session(self, session):
        """Save session object into storage"""

    @abstractmethod
    def purge(self):
        """Purge the sessions"""


class FileBasedSessionManager(AbstractSessionManager):
    """Implement file-based session manager"""

    SESSION_DIRNAME = "sessions"

    def __init__(self, base_directory=None):
        self.base_directory = base_directory or PIPES_CONFIG_DIRECTORY
        self.session_directory = self.get_session_directory()

    def get_session_directory(self):
        os.makedirs(self.base_directory, exist_ok=True)
        return self.base_directory

    def save_session(self, session):
        session_file = os.path.join(self.session_directory, "session")
        with open(session_file, "wb") as fw:
            pickle.dump(session.data, fw)

    def get_session_data_by_id(self):
        if os.path.isfile(self.base_directory, "session"):
            raise ValueError("No session file.")

        session_file = os.path.join(self.session_directory, "session")
        with open(session_file, "rb") as fr:
            data = pickle.load(fr)
        return data

    def purge(self):
        """Purge the sessions in store"""
        if not os.path.exists(self.session_directory):
            rmtree(self.session_directory)

    def access_time(self, session_id):
        session_file = os.path.join(self.session_directory, session_id)
        if not os.path.exists(session_file):
            return None
        timestamp = os.path.getmtime(session_file)
        return datetime.fromtimestamp(timestamp)

    def check_expiration(self, session_id):
        access_time = self.access_time(session_id)
        if not access_time:
            return True

        delta = datetime.now() - self.access_time(session_id)
        if delta >= timedelta(seconds=PIPES_SESSION_EXPIRE):
            return True
        return False


class Session:
    def __init__(self, data=None, base_directory=None):
        self._changed = False
        self._manager = FileBasedSessionManager(base_directory=base_directory)
        file = os.path.join(self._manager.base_directory, 'session')
        if os.path.isfile(file):
            with open(file, "rb") as fr:
                self.data = pickle.load(fr)
        else:
            self.data = {}

        if data and isinstance(data, dict):
            self.data.update(data)

    def save(self):
        """Save the session into underlying storage"""
        self._manager.save_session(self)
        self._changed = False

    def has_key(self, key):
        return key in self.data

    def pop(self, key, default=None):
        value = self.data.pop(key, default)
        self._changed = True
        return value

    def update(self, data):
        self.data.update(data)
        self._changed = True

def create_session(session, settings):
    breakpoint()
    session = Session()
    session.save()

    settings.save()
    return session


def get_or_create_pipes_session():
    manager = FileBasedSessionManager()
    settings = ClientSettings()
    file = os.path.join(manager.base_directory, 'session')
    
    if not os.path.isfile(file):
        session = Session()
        session.save()
        settings.save()
        return session
    return Session()

def get_token():
    session = get_or_create_pipes_session()
    return session.data["token"]